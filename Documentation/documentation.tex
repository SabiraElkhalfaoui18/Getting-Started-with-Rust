\documentclass[a4paper,12pt]{report}

% Font setup: Headlines in sans-serif (Arial), Body in serif (Times New Roman)
\usepackage{lmodern} % Ensures better font rendering
\usepackage{helvet} % Arial for headings
\usepackage{times}  % Times New Roman for body text

% Essential packages
\usepackage{xcolor}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{titlesec}
\usepackage[utf8]{inputenc}   % Allow UTF-8 encoding
\usepackage[arabic,english]{babel} % Load Arabic language
\usepackage{amsmath, amssymb, amsthm}
\usepackage[a4paper, left=1.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm]{geometry}

% Define Theorem, Definition, and Example environments
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}

% Formatting section titles (Sans-serif for headings)
\titleformat{\section}{\sffamily\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\sffamily\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\sffamily\normalsize\bfseries}{\thesubsubsection}{1em}{}
\renewcommand\thesection{\arabic{section}.}
%%%%%%%%%%%%%%%%%%%%%
\usepackage{tocloft}
\usepackage{xcolor}
\usepackage{hyperref}
\definecolor{rustorange}{RGB}{183,65,14} % Define Rust color

\hypersetup{
	linkcolor=rustorange,  % Set the color for links in the ToC
	citecolor=rustorange,
	filecolor=rustorange,
	urlcolor=rustorange,
	pdfborder={0 0 0},      % Remove the underline for the links
	colorlinks=true          % Ensure the links are colored and not boxed or underlined
}

% Change the color of the section titles in the ToC
\renewcommand{\cftsecfont}{\color{rustorange}}  
\renewcommand{\cftsubsecfont}{\color{rustorange}}  
\renewcommand{\cftsubsubsecfont}{\color{rustorange}}

% Change the color of page numbers in the ToC
\renewcommand{\cftsecpagefont}{\color{rustorange}} % Section page numbers
\renewcommand{\cftsubsecpagefont}{\color{rustorange}} % Subsection page numbers
\renewcommand{\cftsubsubsecpagefont}{\color{rustorange}} % Subsubsection page numbers






% Define Rust syntax highlighting
\lstdefinelanguage{Rust}{
	morekeywords={fn, let, mut, match, if, else, loop, while, for, in, break, continue, return, struct, enum, impl, trait, pub, use, mod, crate, const, static, ref, move, async, await, unsafe, type, as, where, super, Self, Box, Vec, String, Result, Option, Some, None, Ok, Err},
	sensitive=true,
	morecomment=[l]{//},
	morecomment=[s]{/*}{*/},
	morestring=[b]",
}
\definecolor{aog}{rgb}{0.0, 0.5, 0.0}
% Listings configuration
\lstset{
	language=Rust,
	basicstyle=\ttfamily\footnotesize,
	keywordstyle=\color{blue}\bfseries,
	commentstyle=\color{aog},
	stringstyle=\color{red},
	breaklines=true,
	numbers=left,
	numberstyle=\tiny\color{gray},
	frame=single,
	backgroundcolor=\color{rustorange!10},
	tabsize=4,
	showspaces=false,
	showstringspaces=false,
	captionpos=b,
}

%%%%%%%%%%%%Colorbox
\usepackage{tcolorbox}
\definecolor{rustorange}{rgb}{0.72, 0.25, 0.05}
\definecolor{rustdark}{rgb}{0.8, 0.33, 0.0}

\newtcolorbox{takeawaybox}{
	colback=rustorange!10, colframe=rustdark, % Light Rust orange background, dark Rust frame
		title={\includegraphics[width=1cm]{takeway.png} }, % Title formatting
	fonttitle=\sffamily\bfseries, % Sans-serif bold title
	coltitle=white, % Title color
	boxrule=0.8pt, % Border thickness
	rounded corners, % Rounded box
	sharp corners=south,
}

\newtcolorbox{explanationbox}{
	colback=rustdark, colframe=rustorange!20, % Slightly deeper Rust orange background, dark Rust frame
	coltext=white,
	title={\includegraphics[width=1cm]{lamp.png} }, % Title formatting
	fonttitle=\sffamily\bfseries, % Sans-serif bold title
	coltitle=black, % Title color
	boxrule=0.8pt, % Border thickness
	rounded corners, % Rounded box
	sharp corners=south,
}

\makeatletter
\renewcommand{\maketitle}{
	\begin{center}
		{\scshape \huge \color{rustorange}Getting Started with Rust}\par\vspace{1cm}
		{\Large \color{rustorange}\textbf{Sabira El Khalfaoui}}\par\vspace{1cm}
		{\large \color{rustorange}\today}\par\vspace{1cm}
		
		% Include Rust logo after title, author, and date
		\includegraphics[width=5cm]{rust_logo.png}
	\end{center}
}
\makeatother
% Title page
\title{\textbf{ \color{rustorange}Getting Started with Rust}}
\author{\large \color{rustorange}\textbf{Sabira El Khalfaoui}}

\date{ \color{rustorange}March 1, 2025}


\begin{document}
	
	\maketitle
	\renewcommand{\contentsname}{\color{rustorange}\textbf{Table of Contents}}
	
	\tableofcontents
	
	\newpage
	\section*{Introduction}
	Rust is a modern systems programming language designed to provide performance, reliability, and safety. Like C and C++, it is a compiled language, meaning that the code is translated directly into machine code before execution, making it faster than interpreted languages like Python.
	
	Rust was initially developed by Graydon Hoare in 2007 and later sponsored by Mozilla in 2009. The first stable release appeared in 2015. Over the years, Rust has consistently ranked as the most admired programming language in the Stack Overflow Developer Survey. Companies like Discord, Dropbox, Amazon, Facebook, and Microsoft use Rust due to its efficiency and reliability.
	
	In February 2024, the White House recommended that companies transition from C and C++ to memory-safe languages like Rust \cite{whitehouse2024}. This highlights one of Rust’s core strengths: balancing speed, safety, concurrency, and portability.
	
	\subsection*{Why Rust?}
	Rust offers several key advantages over other systems programming languages:
	\begin{itemize}
		\item \textbf{Speed}: Like C and C++, Rust compiles to efficient machine code, allowing low-level control over system resources without sacrificing performance.
		\item \textbf{Safety}: Unlike C and C++, Rust eliminates entire classes of memory-related bugs by enforcing strict ownership and borrowing rules, reducing issues like null pointer dereferencing and buffer overflows.
		\item \textbf{Concurrency}: Rust provides powerful tools to write safe and efficient concurrent programs, reducing common issues like data races and dangling references.
		\item \textbf{Portability}: Rust compiles to native binaries that run on Windows, Linux, and macOS without modification, making it highly portable.
	\end{itemize}
	
		\noindent Rust does not use traditional garbage collection like Python or Java. Instead, it relies on a unique ownership model, which we will explore in detail in Sections \ref{own} and \ref{borr}. Additionally, Rust includes a package manager called Cargo, which simplifies dependency management and project building, similar to npm for JavaScript or pip for Python.
	
		\noindent For official documentation, visit: \href{https://doc.rust-lang.org/book/}{The Rust Programming Language}.
	
	
	\subsection*{Installation Steps}
	\textbf{Windows:}
	\begin{enumerate}
		\item Download and run the installer from \href{https://rustup.rs/}{rustup.rs}.
		\item Follow the installation instructions in the terminal.
		\item Restart your terminal and run:
		\begin{lstlisting}
	rustc --version
		\end{lstlisting}
		to verify the installation.
	\end{enumerate}
	
	\textbf{Linux/macOS:}
	\begin{enumerate}
		\item Open a terminal and run:
		\begin{lstlisting}
	curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
		\end{lstlisting}
		\item Follow the on-screen instructions.
		\item Restart the terminal and verify the installation:
		\begin{lstlisting}
	rustc --version
		\end{lstlisting}
	\end{enumerate}
	
	\subsection*{What Gets Installed?}
	When installing Rust, the following tools are included:
	\begin{itemize}
		\item \textbf{Rust Compiler (rustc)} - Compiles Rust code into machine code.
		\item \textbf{Cargo} - Rust’s package manager and build system.
		\item \textbf{Rust Standard Library} - Provides essential functionality.
	\end{itemize}
	
	Once installed, you are ready to write and compile your first Rust program!
	
	\section*{First Program in Rust -- Hello World!}
	Let's start with the classic \texttt{Hello, World!} program in Rust.
	
	\subsection*{Creating a New File}
	First, create a new file named \texttt{hellorust.rs}, where \texttt{.rs} stands for Rust source files. Open the file in your favorite text editor and add the following code:
	
	\begin{lstlisting}
		fn main() {
			println!("Hello, world!");
		}
	\end{lstlisting}
	
	\subsection*{Understanding the Code}
	\begin{itemize}
		\item \textbf{fn main()} - The \texttt{main} function is the entry point of every Rust program.
		\item \textbf{println!} - This macro prints text to the console.
	\end{itemize}
	
	\subsection*{Compiling and Running the Program}
	There are two main ways to compile and run Rust programs: using \texttt{rustc} and using \texttt{cargo}. 
	
	\subsubsection*{Method 1: Using \texttt{rustc}}
	\texttt{rustc} is the Rust compiler that compiles a single file into an executable. It’s straightforward but less flexible for larger projects.
	
	\begin{enumerate}
		\item Open a terminal and navigate to the folder where you saved the \texttt{hellorust.rs} file.
		\item Compile the program with the command:
		\begin{lstlisting}
	rustc hellorust.rs
		\end{lstlisting}
		This will create an executable file named \texttt{hellorust} (or \texttt{hellorust.exe} on Windows).
		\item Run the program by typing:
		\begin{lstlisting}
	./hellorust
		\end{lstlisting}
%		On Windows, just type:
%		\begin{lstlisting}
%			hellorust.exe
%		\end{lstlisting}
	\end{enumerate}
	
		\noindent This method works well for small programs, but it can get tricky when dealing with dependencies or larger projects.
	
	\subsubsection*{Method 2: Using \texttt{cargo}}
	\texttt{cargo} is the official Rust package manager and build tool. It makes it easier to manage larger projects, handle dependencies, and automate tasks like building and testing.
	
	\begin{enumerate}
		\item Create a new Rust project using the following command:
		\begin{lstlisting}
	cargo new hello_rust
	cd hello_rust
		\end{lstlisting}
		\noindent	This will generate a new project folder with the necessary files.
		\item Replace the contents of the \texttt{src/main.rs} file with the \texttt{Hello, World!} code.
		\item Build and run the program with:
		\begin{lstlisting}
	cargo run
		\end{lstlisting}
		\noindent 	This command compiles the code and runs the executable in one step.
	\end{enumerate}
	
	\subsubsection*{Key Differences Between \texttt{rustc} and \texttt{cargo}}
	\begin{itemize}
		\item \textbf{Single-file vs. Project-based}: \texttt{rustc} compiles a single file, while \texttt{cargo} is designed for larger projects with multiple files and dependencies.
		\item \textbf{Automation}: \texttt{cargo} automatically handles tasks like compiling and managing dependencies, making it more convenient for larger projects.
		\item \textbf{Development Workflow}: With \texttt{cargo}, you get commands like \texttt{cargo build} and \texttt{cargo test} to automate the build and testing process, whereas \texttt{rustc} only compiles.
		\item \textbf{Easier for Beginners}: Although \texttt{rustc} is simpler for a one-off file, \texttt{cargo} helps beginners manage and scale their projects easily as they grow.
	\end{itemize}
	
		\noindent \texttt{cargo} is generally the recommended tool for Rust development, especially as you start working on larger projects.
	
	
	
	\section{Primitive data types}

Rust is a statically typed language, meaning you must declare the type of data you're using. The most basic types are scalar types, which represent single values. Some common scalar data types in Rust include:

\begin{itemize}
	\item \textbf{Integer types} (\texttt{int}): Used to represent whole numbers.
	\begin{itemize}
		\item \textbf{Signed integers} (can be positive or negative): \texttt{i8}, \texttt{i16}, \texttt{i32}, \texttt{i64}, \texttt{i128}.
		\item \textbf{Unsigned integers} (can only be positive): \texttt{u8}, \texttt{u16}, \texttt{u32}, \texttt{u64}, \texttt{u128}.
	\end{itemize}
	\item \textbf{Floating-point types} (\texttt{float}): Used to represent numbers with decimals.
	\begin{itemize}
		\item \texttt{f32} (32-bit) and \texttt{f64} (64-bit).
	\end{itemize}
	\item \textbf{Boolean type} (\texttt{bool}): Represents \texttt{true} or \texttt{false}.
	\item \textbf{Character type} (\texttt{char}): Represents a single character.
\end{itemize}

	\noindent Here is an example demonstrating how Rust handles integers, floating-point numbers, booleans, and characters:

\begin{lstlisting}
	fn main() {
		// Integer types
		let x: i32 = -50; // signed 32-bit integer
		let y: u64 = 10090; // unsigned 64-bit integer
		println!("Signed integer {}", x);
		println!("Unsigned integer {}", y);
		
		// Difference between i32 (32-bit) and i64 (64-bit)
		let e: i32 = 2147483647; // maximum value of i32
		let i: i64 = 9223372036854775807; // maximum value of i64
		println!("Maximum value of i32: {}", e);
		println!("Maximum value of i64 {}", i);
		
		// Floating-point types (f32, f64)
		let pi: f64 = 3.14; // 64-bit floating point
		println!("The value of pi is {}", pi);
		
		// Boolean values (true or false)
		let value: bool = true;
		println!("The value is {}", value);
		let is_raining: bool = true;
		println!("Is it raining? {}", is_raining);
		// Character type (char)
		let letter: char = 'z';
		println!("The first letter of the alphabet: {}", letter);
	}
\end{lstlisting}


\begin{explanationbox}
	This example demonstrates Rust's scalar data types:
	
	\begin{itemize}
		\item \textbf{Integer types}: \texttt{i32} for signed integers and \texttt{u64} for unsigned.
		\item \textbf{Maximum values}: Displaying the limits of \texttt{i32} and \texttt{i64}.
		\item \textbf{Floating-point types}: Using \texttt{f64} for precision.
		\item \textbf{Boolean type}: Defining \texttt{true} and \texttt{false} values.
		\item \textbf{Character type}: Storing single Unicode characters.
	\end{itemize}
\end{explanationbox}



\subsection*{Exercise: Experimenting with Data Types}
Modify the program to observe Rust’s type constraints and precision limits.

\begin{lstlisting}
	// Integer Overflow
	let overflow_i32: i32 = 2147483648; // Exceeds i32 limit
	let overflow_i64: i64 = 9223372036854775808; // Exceeds i64 limit
	
	// Floating-Point Precision
	let pi: f32 = 3.141592653589793;
	println!("Pi with f32: {}", pi);
	
	// Boolean Logic
	let is_day: bool = false;
	if is_day {
		println!("It is daytime.");
	} else {
		println!("It is nighttime.");
	}
	
	// Character Type
	let symbol: char = 'choose dollar symbol';
	let emoji: char = 'choose an emoji';
	println!("Symbol: {}", symbol);
	println!("Emoji: {}", emoji);
\end{lstlisting}

	\noindent In Rust, $\{:.2\}$ is used to format a floating-point number (f32) to display only two decimal places.

\begin{lstlisting}
	let num: f32 = 3.14159;
	println!("Formatted number: {:.2}", num);
\end{lstlisting}

	\noindent Try different values and observe the results.

	
	
\section{Compound Data Types in Rust}

In Rust, compound data types allow us to group multiple values together. There are four main types: \textbf{arrays}, \textbf{tuples}, \textbf{slices}, and \textbf{strings (string slices)}.

\subsection*{Arrays}
Arrays store a fixed number of elements of the same type.

\begin{lstlisting}[language=Rust]
	let numbers: [i32; 5] = [1, 2, 3, 4, 5];
	println!("Number Array {:?}", numbers);
\end{lstlisting}

	\noindent Here, \texttt{numbers} is an array of 5 integers. The \texttt{:?} in \texttt{println!} is used for \textbf{debug formatting}, which helps display the array in a readable format.

\begin{itemize}
	\item \texttt{:?} is useful for printing complex data types like arrays in a human-readable form, especially during debugging.
\end{itemize}

	\noindent Another example with an array of strings:

\begin{lstlisting}[language=Rust]
	let fruits: [&str; 3] = ["Apple", "Banana", "Orange"];
	println!("Fruits Array: {:?}", fruits);
	println!("Fruit: {:?}", fruits[2]);
\end{lstlisting}

\subsection*{Tuples}
Tuples hold a fixed number of elements, and these elements can be of different types.

\begin{lstlisting}[language=Rust]
	let human: (String, i32, bool) = ("Alice".to_string(), 30, false);
	println!("Human Tuple {:?}", human);
\end{lstlisting}

	\noindent In the above example, \texttt{human} is a tuple containing a \texttt{String}, an \texttt{i32}, and a \texttt{bool}. Tuples are useful when you need to group multiple values of different types.

A tuple with mixed types:

\begin{lstlisting}[language=Rust]
	let my_mix_tuple = ("coco".to_string(), 23, true, [1, 2, 3, 4, 5]);
	println!("My mix tuple is {:?}", my_mix_tuple);
\end{lstlisting}

\subsection*{Slices}
Slices are a view into a contiguous sequence of elements, like part of an array or string.

\begin{lstlisting}[language=Rust]
	let number_slices: &[i32] = &[1, 2, 3, 4, 5];
	println!("Number Slices {:?}", number_slices);
\end{lstlisting}

\begin{itemize}
	\item \textbf{Slices} are like references to parts of an array or string. They allow us to access a portion of the data without copying it.
\end{itemize}

\subsection*{Strings vs String Slices}
A \textbf{String} is a mutable and growable type stored on the heap, whereas a \textbf{string slice (\&str)} is a reference to part of a string, stored on the stack.

\begin{lstlisting}[language=Rust]
	let mut stone_cold: String = String::from("hell, ");
	stone_cold.push_str("Yeah!");
	println!("Stone Cold says: {}", stone_cold);
\end{lstlisting}

	\noindent In this example, \texttt{stone\_cold} is a \textbf{String} that can grow dynamically as we add more text.

A slice of a string:

\begin{lstlisting}[language=Rust]
	let string: String = String::from("Hello World");
	let slice: &str = &string[0..5];
	println!("Slice Value: {}", slice);
\end{lstlisting}

	\noindent Here, \texttt{slice} is a reference to the first 5 characters of the string \texttt{string}. Notice that a string slice is a view of the original string but does not own the data.

\subsection*{Why use \texttt{:?} in \texttt{println!}?}
The \texttt{:?} is used in Rust’s \texttt{println!} macro for \textbf{debug formatting}. It helps print values in a human-readable form (like arrays and tuples). Without it, printing compound types might give a less readable or more cryptic output.

\begin{itemize}
	\item \texttt{:?} helps in debugging by making complex data structures more readable.
	\item Example:
	\begin{lstlisting}[language=Rust]
		let numbers: [i32; 5] = [1, 2, 3, 4, 5];
		println!("Numbers Array: {:?}", numbers);
	\end{lstlisting}
	\item Output: \texttt{[1, 2, 3, 4, 5]}
\end{itemize}

\subsection*{Memory Management in Rust}

\begin{itemize}
	\item \textbf{Stack vs Heap:}
	\begin{itemize}
		\item \textbf{Heap Memory} is slower because it allows dynamic allocation and deallocation at runtime.
		\item \textbf{Stack Memory} is faster because it stores data in a well-organized and fixed-size manner.
	\end{itemize}
	\item Rust automatically \textbf{cleans up} any memory allocated to a variable when it's no longer used. This is a part of Rust's ownership system, which ensures efficient memory management without the need for garbage collection.
\end{itemize}

\subsection*{Troubleshooting "Cannot Find Value" Errors}
If you try to use a variable that is not defined or is out of scope, you will get an error like:  
\textbf{"cannot find value of slice"}.

For example:

\begin{lstlisting}[language=Rust]
	fn print() {
		println!("Slice: {}", slice);
	}
\end{lstlisting}

	\noindent This will cause an error because \texttt{slice} was never declared inside the function. To fix this, you need to ensure that the variable is defined or passed into the function properly.

\begin{itemize}
	\item \textbf{Tip:} Always check that a variable is properly scoped before using it inside functions.
\end{itemize}

	
	
	
\section{Functions in Rust}

Functions are a fundamental concept in programming. A function is a reusable block of code that performs a specific task. Functions help in organizing code, avoiding repetition, and improving readability.

	\noindent In Rust, functions are defined using the keyword \texttt{fn}, followed by the function name, parentheses (which may contain parameters), and curly braces enclosing the function body.

\subsection*{The \texttt{main} Function}

In Rust, every executable program must have a \texttt{main} function, which serves as the entry point of the program. If the \texttt{main} function is missing, Rust will return an error.

\begin{lstlisting}
	fn main() {
		println!("Hello, Rust!");
	}
\end{lstlisting}

	\noindent If we do not define a \texttt{main} function, we will encounter the following error:

\begin{lstlisting}
	error: `main` function not found in crate
\end{lstlisting}

	\noindent If we define another function but do not call it inside \texttt{main}, we get a warning that the function is never used:

\begin{lstlisting}
	fn no_main() {
		println!("There is no main function");
	}
\end{lstlisting}

	\noindent Error:

\begin{lstlisting}
	warning: function `no_main` is never used
	error: `main` function not found
\end{lstlisting}

	\noindent To avoid this, always define the \texttt{main} function as the entry point of your program.

\subsection*{Defining Functions in Rust}

A function in Rust follows this structure:

\begin{lstlisting}
	fn function_name() {
		// Function body
	}
\end{lstlisting}

	\noindent Function names should follow \textbf{snake\_case} (lowercase letters with underscores). For example:

\begin{lstlisting}
	fn main() {
		hello_rust(); // Calling the function
	}
	fn hello_rust() {
		println!("Hello, Rust!");
	}
\end{lstlisting}

	\noindent Rust allows calling functions before or after their definitions. This feature is known as \textbf{hoisting}.

\subsection*{Functions with Parameters}

Functions can accept parameters (input values). Each parameter has a specified type:

\begin{lstlisting}
	fn rectangle_height(height: f32) {
		println!("The height of the rectangle is {}", height);
	}
	
	fn rectangle_width(width: f32) {
		println!("The width of the rectangle is {}", width);
	}
\end{lstlisting}

	\noindent Functions can also accept multiple parameters:

\begin{lstlisting}
	fn student_info(name: String, age: u32, grade: u32) {
		println!("The student name is {}, age is {}, and grade is {}", name, age, grade);
	}
\end{lstlisting}

\subsection*{Expressions and Statements}
\begin{itemize}
	\item  A \textbf{statement} is an instruction that does not return a value (e.g., variable declaration).
	\item  An \textbf{expression} evaluates to a value (e.g., a mathematical operation, function call, or block of code).
\end{itemize}

	\noindent \textbf{Example}

\begin{lstlisting}
	let x = {
		let h: u32 = 10;
		let w: u32 = 12;
		h * w  // No semicolon since this is an expression
	};
\end{lstlisting}

	\noindent \textbf{Note:} The last expression inside a block does not require a semicolon because it returns a value.

\subsection*{Functions Returning Values}

A function can return a value by specifying the return type after \texttt{->}:

\begin{lstlisting}
	fn multiply(a: i32, b: i32) -> i32 {
		a * b  // No semicolon since this is an expression
	}
\end{lstlisting}

	\noindent Calling the function inside \texttt{main} can be done in two ways:

\begin{lstlisting}
	fn main() {
		let result = multiply(6, 4);
		println!("The result is {}", result);
		println!("The result is {}", multiply(2, -4));
	}
\end{lstlisting}

\subsection*{Example: Calculating Rectangle Area}

A function that returns the area of a rectangle:

\begin{lstlisting}
	fn rectangle_area(height: f32, width: f32) -> f32 {
		height * width
	}
\end{lstlisting}


\begin{takeawaybox}
	Functions help organize code and avoid repetition.
	\begin{itemize}
		\item The 	\texttt{main} function is mandatory as the entry point.
		\item Rust functions follow the snake\_case naming convention.
		\item Functions can take parameters and return values.
		\item Statements do not return values, while expressions do.
		\item The last expression inside a function block should not have a semicolon if it is meant to return a value.
		\item Hoisting allows calling functions before their definition.
	\end{itemize}
\end{takeawaybox}



\section{Ownership in Rust}\label{own}

Rust's ownership system is a unique feature that ensures memory safety without needing a garbage collector. It allows Rust to manage memory efficiently while preventing common issues like dangling pointers and data races.

\subsection*{What is Ownership?}
Ownership is a set of rules that governs how Rust manages memory. The key idea is that every value in Rust has a single owner—each variable owns its value, and only one variable can own a value at a time.

\subsection*{Ownership Rules}
Rust enforces three fundamental ownership rules:
\begin{enumerate}
	\item Each value in Rust has a variable that is its owner.
	\item There can be only one owner at a time.
	\item When the owner goes out of scope, the value is automatically dropped.
\end{enumerate}

\subsection*{Each Value Has a Unique Owner}
In Rust, every value is owned by a single variable, and ownership can be passed without duplication. However, Rust allows passing references to avoid transferring ownership. 

\begin{lstlisting}
	// The variable s1 owns the String "Rust"
	fn main() {
		let s1 = String::from("Rust"); 
		let len = calculate_length(&s1); // Passing a reference, not ownership
		println!("Length of '{}' is {}", s1, len);
	}
	
	fn calculate_length(s: &String) -> usize { 
		s.len()
	}
\end{lstlisting}

	\noindent In this example, \texttt{s1} is the owner of the string "Rust". Instead of transferring ownership to the function, we pass a reference \texttt{\&s1}. This allows \texttt{calculate\_length} to use the value without taking ownership, enabling us to still use \texttt{s1} after the function call.

\subsection*{Only One Owner at a Time}
If ownership is transferred from one variable to another, the previous owner loses access to the value.

\begin{lstlisting}
	fn main(){
		let s1 = String::from("Rust");
		let s2 = s1; // Ownership of s1 is transferred to s2
		println!("{}", s2);
	}
\end{lstlisting}

	\noindent Here, \texttt{s1} transfers ownership to \texttt{s2}. After this transfer, \texttt{s1} is no longer valid. If we try to use \texttt{s1} after this point, the Rust compiler will throw an error because ownership has moved to \texttt{s2}.

\subsection*{Dropping Values When Owner Goes Out of Scope}
When a variable goes out of scope, Rust automatically deallocates the memory.

\begin{lstlisting}
	fn main(){
		let s1 = String::from("Rust");
		let len = calculate_length(s1);
		println!("Length of '{}' is {}", s1, len); // This will cause an error
	}
	
	fn calculate_length(s: String) -> usize { 
		s.len()
	}
\end{lstlisting}

	\noindent Here, \texttt{s1} is moved into \texttt{calculate\_length}. Because the function takes ownership of \texttt{s1}, it is no longer valid in the \texttt{main} function, leading to a compile-time error when trying to use \texttt{s1} after calling \texttt{calculate\_length}.


	\noindent\textbf{Solution: }

\begin{lstlisting}
	fn main() {
		let s1 = String::from("Rust");
		let len = calculate_length(&s1); // Pass reference, not ownership
		println!("Length of '{}' is {}", s1, len); // Works fine
	}
	
	fn calculate_length(s: &String) -> usize { 
		s.len() // Read-only access to s
	}
\end{lstlisting}
\textbf{Why Does This Work?}

\begin{itemize}
	\item \texttt{\&s1} borrows \texttt{s1} instead of taking ownership.
	\item \texttt{s} inside \texttt{calculate\_length} is a reference to \texttt{s1}, so it does not get dropped.
	\item \texttt{s1} remains valid in \texttt{main()}, and we can use it after calling \texttt{calculate\_length}.
\end{itemize}


\begin{takeawaybox}
	\begin{itemize}
		\item Rust ensures memory safety through ownership rules without requiring a garbage collector.
		\item Ownership can be transferred (moved) between variables, making the previous owner invalid.
		\item Passing references (\texttt{\&}) allows borrowing instead of transferring ownership.
		\item When an owner goes out of scope, the value is automatically dropped.
	\end{itemize}
\end{takeawaybox}



	
	
	\section{References and Borrowing}\label{borr}
	
	In Rust, references and borrowing are fundamental concepts that enhance both \textbf{memory safety} and \textbf{performance}. Instead of transferring ownership of a value, Rust allows borrowing, enabling multiple parts of the program to access data without unnecessary duplication. This mechanism helps prevent issues such as use-after-free errors while maintaining efficient memory usage.
	
	\subsection*{Why Borrowing is Important}
	Borrowing ensures that:
	\begin{itemize}
		\item A variable has only \textbf{one owner} at any given time.
		\item You can \textbf{borrow a value} without taking ownership, allowing safe concurrent access.
		\item It improves memory management since Rust does not allow multiple owners of the same data, preventing \textbf{dangling pointers}.
	\end{itemize}
	
	There are two types of references in Rust:
	\begin{itemize}
		\item \textbf{Immutable references} (read-only access, multiple allowed).
		\item \textbf{Mutable references} (write access, only one at a time).
	\end{itemize}
	
	 \subsection*{Immutable References}
	An immutable reference allows read access to a variable without modifying it. This is useful when multiple parts of a program need to read a value simultaneously without modifying it.
	
	\noindent To create an immutable reference, we use the '\&' symbol:
	
	\begin{lstlisting}[language=Rust]
		fn main() {
			let x: i32 = 5;
			let r: &i32 = &x; // Immutable reference
			println!("The value of x is {}", x);
			println!("The value of r is {}", r);
		}
	\end{lstlisting}
	
	\noindent This example demonstrates that 'r' can access the value of 'x' without taking ownership, allowing safe memory access.
	
	\subsection*{Mutable References}
	A mutable reference allows modification of the value. However, Rust enforces \textbf{exclusive access}: you can have \textbf{either one mutable reference or multiple immutable references} at a time, but not both.
	
	\begin{lstlisting}[language=Rust]
		fn main() {
			let mut x: i32 = 5;
			let r: &mut i32 = &mut x; // Mutable reference
			*r += 1; // Modify the value
			*r -= 3;
			println!("The value of r is {}", *r);
		}
	\end{lstlisting}
	
		\noindent In this example, 'r' is the only reference to 'x', allowing modifications without conflicts.
	
	\subsection*{Borrowing in Structs}
	Borrowing also applies when working with structs. Consider a simple bank account structure:
	
	\begin{lstlisting}[language=Rust]
		fn main() {
			let mut account = BankAccount {
				owner: "Alice".to_string(),
				balance: 150.55,
			};
			
			// Immutable borrow to check the balance
			account.check_balance();
			
			// Mutable borrow to withdraw money
			account.withdraw(50.0);
			
			account.check_balance();
		}
		
		struct BankAccount {
			owner: String,
			balance: f64,
		}
		
		impl BankAccount {
			fn withdraw(&mut self, amount: f64) {
				println!("Withdrawing {} from account owned by {}", amount, self.owner);
				self.balance -= amount;
			}
			
			fn check_balance(&self) {
				println!("Account owned by {} has a balance of {:.2}", self.owner, self.balance);
			}
		}
	\end{lstlisting}
	
	\subsection*{Preventing Data Races} 
	Rust’s borrowing rules prevent \textbf{data races}, which occur when:
	\begin{itemize}
		\item Two or more threads access the same data concurrently.
		\item At least one thread modifies the data.
		\item There is no synchronization mechanism to ensure safe access.
	\end{itemize}
	
	By enforcing borrowing rules at compile time, Rust guarantees that mutable and immutable accesses do not overlap, eliminating data races entirely.
	
\begin{takeawaybox}
	\begin{itemize}
		
		\item Borrowing allows accessing a value without transferring ownership.
		\item Immutable references let multiple parts of the program read data concurrently.
		\item Mutable references ensure exclusive modification rights.
		\item  Rust prevents \textbf{data races} by enforcing borrowing rules at compile time.
		\item  These borrowing principles help Rust guarantee memory safety while maintaining efficiency.
		
	\end{itemize}
\end{takeawaybox}
	
	
	
	\section{Variables and Mutability}
	
	
	Rust provides strict rules for variable management to ensure safety and performance. By default, variables in Rust are \textbf{immutable}, meaning their values cannot be changed after they are assigned. This immutability helps prevent unintended modifications and makes code easier to reason about. However, if we need to modify a variable’s value, we can explicitly declare it as \textbf{mutable} using the \texttt{mut} keyword.
	
	\subsection*{Immutable Variables}
	In Rust, when a variable is declared without the \texttt{mut} keyword, its value cannot be changed after initialization. For example, the following code will result in a compilation error:
	
	\begin{lstlisting}[language=Rust]
		fn main() {
			let x = 5;
			x = 10; // Error: cannot assign twice to immutable variable
		}
	\end{lstlisting}
	
		\noindent This default behavior encourages developers to use immutable variables whenever possible, leading to safer and more predictable code.
	
	\subsection*{Mutable Variables}
	To allow modification of a variable, we use the \texttt{mut} keyword. This tells the Rust compiler that the variable’s value can change. The following example demonstrates this:
	
	\begin{lstlisting}[language=Rust]
		fn main() {
			let mut a: i32 = 15;
			println!("The value of a is {}", a);
			a = 10;
			println!("The value of a is {}", a);
		}
	\end{lstlisting}
	
	\noindent Here:
	\begin{itemize}
		\item We declare a mutable variable \texttt{a} with the type \texttt{i32} (a 32-bit signed integer) and assign it the value 15.
		\item We print its initial value.
		\item We then modify \texttt{a} by assigning it a new value (10).
		\item Finally, we print the updated value.
	\end{itemize}
	
	Since \texttt{a} is declared as mutable using \texttt{mut}, reassigning a new value to it is allowed.
	
	\subsection*{Why Use Immutability?}
	While mutability is sometimes necessary, Rust encourages immutability by default because:
	\begin{itemize}
		\item It makes code easier to understand and maintain.
		\item It helps prevent accidental modifications.
		\item It improves performance by allowing compiler optimizations.
		\item It makes concurrent programming safer by avoiding data races.
	\end{itemize}
	
		\noindent However, when a variable needs to change, using \texttt{mut} is a valid and intentional choice.
	
	
	\begin{takeawaybox}
		\begin{itemize}
			\item Variables in Rust are immutable by default.
			\item Use the \texttt{mut} keyword to allow modification.
			\item Immutability leads to safer and more predictable code.
			\item Prefer immutable variables unless mutability is necessary.
		\end{itemize}
		
	\end{takeawaybox}
	
\section{Constants}
	Rust provides both \textbf{variables} and \textbf{constants} for storing values, but they have important differences in terms of mutability and scope. While variables can be mutable or immutable, constants are always immutable and cannot be changed after they are defined.
	

\vspace{0.2cm}
		\noindent \textbf{Constants} in Rust are values that are bound to a name and cannot be modified throughout the execution of a program. They are declared using the \texttt{const} keyword and must always include a type annotation. Unlike variables, constants are not assigned using \texttt{let} and cannot be marked as \texttt{mut}. 
	
	\subsection*{Differences Between Variables and Constants}
	\begin{itemize}
		\item Both variables and constants are \textbf{immutable by default}.
		\item Variables can be made \textbf{mutable} using the \texttt{mut} keyword, whereas constants \textbf{cannot} be changed once assigned.
		\item Constants \textbf{must} be explicitly typed, while variables can have their type inferred.
		\item Constants are evaluated at compile time, making them more efficient in certain cases.
		\item Constants can be declared outside of functions, making them accessible throughout the entire program.
	\end{itemize}
	
	\subsection*{Example: Using Constants and Variables}
	The following Rust program demonstrates the difference between constants and variables:
	
	\begin{lstlisting}[language=Rust]
		fn main() {
			println!("Hello, world!");
			
			// A mutable variable
			let mut x = 5;
			
			// A constant with an explicit type annotation
			const Y: i32 = 10;
			
			println!("The value of the variable is {} and the constant is {}", x, Y);
			
			// Accessing predefined constants
			println!("The value of pi is {}", PI);
			println!("Three hours in seconds is {}", THREE_HOURS_IN_SECONDS);
		}
		
		// Declaring constants outside the main function
		const PI: f32 = 3.1415922653;
		const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
	\end{lstlisting}
	

	\begin{explanationbox}
		\begin{itemize}
		\item \texttt{x} is a mutable variable, meaning we can change its value later in the program.
		\item \texttt{Y} is a constant, and attempting to modify it will result in a compilation error.
		\item \texttt{PI} and \texttt{THREE\_HOURS\_IN\_SECONDS} are constants declared outside the \texttt{main} function. Since constants are evaluated at compile time, they can be used anywhere in the program.
	\end{itemize}
	\end{explanationbox}

	\subsection*{Why Use Constants?}
	Constants are useful when a value:
	\begin{itemize}
		\item Should not change throughout the program.
		\item Needs to be used in multiple places without duplication.
		\item Represents a fixed value like mathematical constants or time conversions.
	\end{itemize}
	
\begin{takeawaybox}
		\begin{itemize}
		\item Use \texttt{let} for variables, which can be mutable or immutable.
		\item Use \texttt{const} for values that must remain unchanged.
		\item Constants require a type annotation and cannot be modified.
		\item Declaring constants outside functions allows them to be accessible throughout the program.
	\end{itemize}
\end{takeawaybox}

	\section{Shadowing}
	Rust provides a feature called \textbf{shadowing}, which allows redeclaring a variable with the same name within the same scope. This means that a new variable is created, effectively "hiding" the previous one. Shadowing is useful when you need to transform a variable while maintaining immutability.
	
	\subsection*{Understanding Shadowing}
	In Rust, shadowing works by declaring a new variable with the same name as an existing one. The new variable replaces the old one within its scope, but the old variable still exists outside that scope. 
	
	\subsection*{Key Differences Between Shadowing and Mutability}
	It is important to distinguish shadowing from marking a variable as \texttt{mut}:
	\begin{itemize}
		\item With shadowing, a new variable is created rather than modifying an existing one.
		\item Shadowing allows changing the type of a variable, whereas \texttt{mut} does not.
		\item Shadowing enables transformation of values without allowing unintended modifications elsewhere in the program.
	\end{itemize}
	
	\subsection*{Example: Shadowing in Rust}
	The following Rust program demonstrates how shadowing works in different scopes:
	
	\begin{lstlisting}[language=Rust]
		fn main() {
			let x = 5; // x is initialized with 5
			let x = x + 1; // A new x shadows the previous one, now x is 6
			
			{
				let x = x * 2; // Another shadowing occurs in this inner scope, x is now 12
				println!("The value of x in the inner scope is: {x}");
			}
			
			println!("The value of x in the main function is: {x}"); // x remains 6
		}
	\end{lstlisting}
	

	\begin{explanationbox}
		\begin{itemize}
			\item The first \texttt{let x = 5;} initializes \texttt{x} with 5.
			\item The second \texttt{let x = x + 1;} creates a new variable with the same name, which now holds 6.
			\item Inside the inner scope, \texttt{let x = x * 2;} shadows the previous \texttt{x}, and its value becomes 12.
			\item Outside the inner scope, \texttt{x} is still 6, because the shadowing in the block was limited to that scope.
		\end{itemize}
	\end{explanationbox}
	
	
	\subsection*{Why Use Shadowing?}
	\begin{itemize}
		\item To avoid using \texttt{mut} when performing transformations on a variable.
		\item To allow temporary changes in scope without affecting the original value.
		\item To enable type conversion without requiring a separate variable name.
	\end{itemize}
	
	\begin{takeawaybox}
		\begin{itemize}
			\item Shadowing allows redefining variables with the same name within the same scope.
			\item Unlike \texttt{mut}, shadowing creates a new variable rather than modifying an existing one.
			\item Shadowing enables transformations while keeping variables immutable.
			\item Inner scope shadowing does not affect the variable outside the block.
		\end{itemize}
	\end{takeawaybox}
	
	\section{Comments}
	
	% Comments in Rust
	%---------------------------------
	
	In Rust, comments are an essential part of writing clean and maintainable code. They allow developers to annotate their programs with helpful explanations without affecting how the code runs. Rust provides two types of comments: single-line and multi-line (block) comments.
	
	\subsection*{Single-Line Comments}
	
	A single-line comment starts with \texttt{//} and extends to the end of the line. It is often used to describe what a specific line or block of code does. For example:
	
	\begin{lstlisting}[language=Rust]
		fn main() {
			// This is a single-line comment
			println!("Hello, world!"); // This prints "Hello, world!" to the console
			
			// println!("This line is commented out and won't run");
			
			println!("I feel happy"); // This prints "I feel happy"
		}
	\end{lstlisting}
	
		\noindent In the example above, Rust ignores everything written after \texttt{//} on a given line. You can also temporarily disable a line of code by commenting it out, which is useful for debugging.
	
	\subsection*{Multi-Line (Block) Comments}
	
	For longer explanations, Rust allows block comments, which start with \texttt{/*} and end with \texttt{*/}. These can span multiple lines, making them useful for adding detailed descriptions or temporarily removing large sections of code.
	
	\begin{lstlisting}[language=Rust]
		/*
		This is a block comment.
		It spans multiple lines and is useful for detailed explanations.
		Block comments are also helpful when debugging large sections of code.
		*/
	\end{lstlisting}
	
		\noindent Unlike many other programming languages, Rust does not have built-in documentation comments like Java’s \texttt{/*\textsuperscript{*} ... *\textsuperscript{/}}. Instead, Rust provides a special type of documentation comment using three slashes \texttt{///}, which is used for generating API documentation.
	
	\begin{takeawaybox}
		\begin{itemize}
			\item Use \texttt{//} for short, inline explanations or to temporarily disable code.
			\item Use \texttt{/* ... */} for longer descriptions or multi-line comments.
			\item Commenting helps improve code readability and maintainability.
			\item Rust also provides documentation comments (\texttt{///}) for API documentation.
		\end{itemize}
	\end{takeawaybox}
	
	
\section{Introduction to Control Flow}
	
	In programming, control flow refers to the order in which statements and instructions are executed. Rust provides different mechanisms to control the flow of execution, such as conditional statements (\texttt{if}, \texttt{else if}, and \texttt{else}) and loops.
	
	\subsection*{Conditional Statements}
	
	Conditional statements allow the program to make decisions based on certain conditions.
	
	\begin{lstlisting}[language=Rust]
		// Checking if a person is eligible to drive
		fn main() {
			let age: u16 = 15;
			
			if age >= 18 {
				println!("You can drive a car!");
			} else {
				println!("You can't drive a car!");
			}
		}
	\end{lstlisting}
	
		\noindent In the above example, the program checks whether the variable \texttt{age} is 18 or older. If the condition \texttt{age >= 18} is true, it prints \texttt{"You can drive a car!"}. Otherwise, the \texttt{else} block executes, displaying \texttt{"You can't drive a car!"}.
	
	\subsection*{Multiple Conditions with \texttt{else if}}
	
	Sometimes, we need to check multiple conditions. This is done using \texttt{else if}.
	
	\begin{lstlisting}[language=Rust]
		// Checking divisibility using multiple conditions
		fn main() {
			let number = 9;
			
			if number % 4 == 0 {
				println!("Number is divisible by 4");
			} else if number % 3 == 0 {
				println!("Number is divisible by 3");
			} else if number % 2 == 0 {
				println!("Number is divisible by 2");
			} else {
				println!("Number is not divisible by 4, 3, or 2");
			}
		}
	\end{lstlisting}
	
		\noindent Here, the program checks whether \texttt{number} is divisible by 4, 3, or 2. If none of these conditions are met, the final \texttt{else} block executes.
	
	\subsection*{Using \texttt{if} in a \texttt{let} Statement}
	
	In Rust, \texttt{if} expressions can be used within \texttt{let} statements to assign values conditionally.
	
	\begin{lstlisting}[language=Rust]
		// Assigning a value based on a condition
		fn main() {
			let condition = true;
			let number = if condition { 5 } else { 6 };
			
			println!("Number: {}", number);
		}
	\end{lstlisting}
	
		\noindent In this example, if \texttt{condition} is true, \texttt{number} is assigned 5; otherwise, it is assigned 6.
	
	\begin{takeawaybox}
		\begin{itemize}
			\item The \texttt{if} statement executes a code block based on a condition.
			\item The \texttt{else if} statement allows checking multiple conditions.
			\item The \texttt{else} statement executes when none of the conditions are met.
			\item Rust allows using \texttt{if} expressions inside \texttt{let} statements to assign values based on conditions.
		\end{itemize}
	\end{takeawaybox}
	
	
	
	\section{Iteration in Rust: Using Loops}
	In Rust, loops allow us to execute a block of code multiple times. Rust provides three types of loops: 
	
	\begin{itemize}
		\item \textbf{\texttt{loop}}: An unconditional loop that runs indefinitely unless explicitly stopped.
		\item \textbf{\texttt{while}}: Repeats execution while a condition remains true.
		\item \textbf{\texttt{for}}: Iterates over a range or collection.
	\end{itemize}
	
	\subsection*{\texttt{loop}: Infinite Loop Until Stopped}
	
	The \texttt{loop} keyword creates an infinite loop that keeps running until explicitly stopped using \texttt{break}.
	
	\begin{lstlisting}[language=Rust]
		// An infinite loop that prints "Hello, world!" repeatedly
		fn main() {
			loop {
				println!("Hello, world!");
				// Uncomment the next line to stop the loop
				// break;
			}
		}
	\end{lstlisting}
	
		\noindent To exit a \texttt{loop}, we use the \texttt{break} keyword. If we need to return a value when breaking, we can do so like this:
	
	\begin{lstlisting}[language=Rust]
		// Using loop to calculate a result
		fn main() {
			let mut counter = 0;
			
			let result = loop {
				counter += 1;
				
				if counter == 10 {
					break counter * 2;
				}
			};
			
			println!("The result is {result}");
		}
	\end{lstlisting}
	
		\noindent In this example, the loop runs until \texttt{counter} reaches 10, at which point it stops and returns \texttt{counter * 2}.
	
	\subsection*{Loop Labels for Nested Loops}
	
	Rust allows naming loops using labels, which can be helpful when working with nested loops.
	
	\begin{lstlisting}[language=Rust]
		// Using loop labels to break out of a specific loop
		fn main() {
			let mut count = 0;
			
			'counting_up: loop {
				println!("count = {count}");
				let mut remaining = 10;
				
				loop {
					println!("remaining = {remaining}");
					if remaining == 9 {
						break; // Breaks only the inner loop
					}
					if count == 2 {
						break 'counting_up; // Exits the outer loop
					}
					remaining -= 1;
				}
				
				count += 1;
			}
			
			println!("End count = {count}");
		}
	\end{lstlisting}
	
		\noindent Here, \texttt{\textquotesingle counting\_up} is a label for the outer loop. When \texttt{break \textquotesingle counting\_up} is executed, it exits the outer loop instead of just the inner loop.
		
	
	\subsection*{\texttt{while}: Looping While a Condition is True}
	
	A \texttt{while} loop runs repeatedly as long as its condition evaluates to true.
	
	\begin{lstlisting}[language=Rust]
		// Countdown using a while loop
		fn main() {
			let mut number = 3;
			
			while number != 0 {
				println!("{number}");
				number -= 1;
			}
			
			println!("Hey");
		}
	\end{lstlisting}
	
	\noindent In this example, the loop decrements \texttt{number} until it reaches zero, then exits.
	
	\subsection*{\texttt{for}: Iterating Over Collections}
	
	The \texttt{for} loop is commonly used to iterate over elements in a collection, such as an array.
	
	\begin{lstlisting}[language=Rust]
		// Iterating over an array using a for loop
		fn main() {
			let a = [1, 2, 3, 4, 5, 6];
			let b = ["a", "b", "c", "d", "e"];
			
			for element in a {
				println!("{element}");
			}
			
			for letter in b {
				println!("{letter}");
			}
		}
	\end{lstlisting}
	
	\begin{takeawaybox}
	
		\begin{itemize}
			\item The \texttt{loop} keyword creates an infinite loop that must be manually stopped with \texttt{break}.
			\item \texttt{while} loops execute as long as a condition remains true.
			\item \texttt{for} loops iterate over collections and are a safer way to traverse data.
			\item Loop labels (\texttt{'label}) allow breaking or continuing specific loops in nested structures.
		\end{itemize}
	\end{takeawaybox}
	
	
	
	\section{Structs}
	
	In Rust, \textbf{structs} allow us to group related values together under a common name. They are similar to tuples but provide named fields, making them more readable and flexible.
	
	\subsection*{Using Tuples to Group Values}
	Before diving into structs, let’s see an example of a tuple that stores the dimensions of a rectangle.
	
	\begin{lstlisting}[language=Rust]
		// A tuple representing the width and height of a rectangle
		fn main() {
			let rect: (i32, i32) = (200, 500);
		}
	\end{lstlisting}
	
	\noindent Tuples work for simple cases, but they don’t tell us what each value represents. This is where structs become useful.
	
	\subsection*{Defining and Using Structs}
	
	A struct in Rust is defined using the \texttt{struct} keyword. Here’s an example of a struct representing a book:
	
	\begin{lstlisting}[language=Rust]
		// Defining a struct for a book
		struct Book {
			title: String,
			author: String,
			pages: i32,
			available: bool,
		}
	\end{lstlisting}
	
	\noindent Now, let’s define a struct for a user and create an instance:
	
	\begin{lstlisting}[language=Rust]
		// Defining a struct for a user
		struct User {
			active: bool,
			username: String,
			email: String,
			sign_in_count: u64,
		}
		
		fn main() {
			let mut user1: User = User {
				active: true,
				username: String::from("someusername"),
				email: String::from("someusername@m.com"),
				sign_in_count: 1,
			};
			
			println!("User email: {}", user1.email);
		}
	\end{lstlisting}
	
	\noindent Struct fields can be accessed using dot notation (\texttt{user1.email}). Since \texttt{user1} is mutable, we can modify its fields.
	
	\subsection*{Returning Structs from Functions}
	
	A function can return a struct, making it easier to construct new instances:
	
	\begin{lstlisting}[language=Rust]
		// Function to create a new User instance
		fn build_user(email: String, username: String) -> User {
			User {
				active: true,
				email,
				username,
				sign_in_count: 1,
			}
		}
	\end{lstlisting}
	
	\subsection*{Creating a New Instance from an Existing One}
	
	Rust allows creating a new instance based on an existing one using the \texttt{..} syntax:
	
	\begin{lstlisting}[language=Rust]
		let user2: User = User {
			email: String::from("another@m.com"),
			..user1
		};
	\end{lstlisting}
	
	\noindent This means \texttt{user2} gets the same values as \texttt{user1}, except for the \texttt{email} field.
	
	\subsection*{Tuple Structs: Structs Without Named Fields}
	
	Rust supports tuple structs, which behave like tuples but are distinct types:
	
	\begin{lstlisting}[language=Rust]
		// Defining tuple structs
		struct Color(i32, i32, i32);
		struct Point(i32, i32, i32);
		
		fn main() {
			let black: Color = Color(0, 0, 0);
			let white: Color = Color(255, 255, 255);
		}
	\end{lstlisting}
	
	\noindent Tuple structs can be useful when naming the fields isn’t necessary, but you still want to define a distinct type.
	
	\subsection*{Unit-Like Structs}
	
	A unit-like struct has no fields but can still be useful, such as for implementing traits.
	
	\begin{lstlisting}[language=Rust]
		// Defining a unit-like struct
		struct AlwaysEqual;
		
		fn main() {
			let subject: AlwaysEqual = AlwaysEqual;
		}
	\end{lstlisting}
	
	\begin{takeawaybox}
	
		\begin{itemize}
			\item Structs allow grouping related data with named fields, making the code more readable.
			\item Fields in a struct are accessed using dot notation (\texttt{instance.field}).
			\item Functions can return structs, making it easier to create new instances.
			\item The \texttt{..} syntax allows copying fields from another instance.
			\item Tuple structs provide a way to define structs without named fields.
			\item Unit-like structs exist but contain no data, useful for implementing traits.
		\end{itemize}
	\end{takeawaybox}
	
	\section{Enums}
	
	Rust's \textbf{enums} (short for \textit{enumerations}) allow us to define a type that can take on multiple distinct variants. Enums are powerful because they can hold data, unlike enums in many other languages.
	
	\subsection*{Basic Enum Usage}
	
	Let's start with a simple example: representing different types of IP addresses.
	
	\begin{lstlisting}[language=Rust]
		// Defining an enum to represent IP address types
		enum IpAddrKind {
			V4,
			V6,
		}
		
		fn main() {
			let four = IpAddrKind::V4;
			let six = IpAddrKind::V6;
			
			fn route(ip_kind: IpAddrKind) {
				// Function that takes an IpAddrKind
			}
			
			route(IpAddrKind::V4);
			route(IpAddrKind::V6);
		}
	\end{lstlisting}
	
	\noindent Here, \texttt{IpAddrKind} can take two values: \texttt{V4} or \texttt{V6}. This is useful but doesn't store actual IP addresses. To fix this, we can use a \textbf{struct}.
	
	\subsection*{Combining Structs with Enums}
	
	We can define a struct that includes the type of IP address along with its actual value.
	
	\begin{lstlisting}[language=Rust]
		// Using a struct to store both IP type and address
		struct IpAddr {
			kind: IpAddrKind,
			address: String,
		}
		
		fn main() {
			let home = IpAddr {
				kind: IpAddrKind::V4,
				address: String::from("127.0.0.1"),
			};
			
			let loopback = IpAddr {
				kind: IpAddrKind::V6,
				address: String::from("::1"),
			};
		}
	\end{lstlisting}
	
	\noindent While this approach works, Rust provides an even better way—\textbf{storing data directly in an enum}.
	
	\subsection*{Storing Data in an Enum}
	
	Instead of using a struct, we can define the IP address format directly within an enum.
	
	\begin{lstlisting}[language=Rust]
		// Storing IP addresses directly inside an enum
		enum IpAddr {
			V4(u8, u8, u8, u8),
			V6(String),
		}
		
		fn main() {
			let home = IpAddr::V4(127, 0, 0, 1);
			let loopback = IpAddr::V6(String::from("::1"));
		}
	\end{lstlisting}
	
	\noindent Now, \texttt{IpAddr::V4} stores four \texttt{u8} values (for an IPv4 address), while \texttt{IpAddr::V6} holds a \texttt{String}. This approach makes the code cleaner and more expressive.
	
	\begin{takeawaybox}
		
		\begin{itemize}
			\item Enums allow defining a type with multiple variants.
			\item Unlike other languages, Rust's enums can store data.
			\item Structs can be used alongside enums to hold additional information.
			\item Enums provide a cleaner way to store different types of data under a single type.
		\end{itemize}
	\end{takeawaybox}
	
	
	
	\section{Error Handling}
	
	Rust provides two primary approaches for handling errors: the \texttt{Option<T>} and \texttt{Result<T, E>} enums. These mechanisms allow us to write safe and robust code by explicitly handling cases where a value may be absent or an operation may fail.
	
	\subsection*{Approach 1: The \texttt{Option<T>} Enum}
	
	The \texttt{Option<T>} enum is used when a value may or may not be present. This is particularly useful when dealing with optional data, such as the result of a division operation where division by zero is undefined.
	
	\begin{lstlisting}[language=Rust]
		// Defining the Option type (already built into Rust)
		enum Option<T> {  
			Some(T),  // Represents a value
			None,     // Represents the absence of a value
		}
		
		// Function that safely performs division using Option<T>
		fn divide(numerator: f64, denominator: f64) -> Option<f64> {
			if denominator == 0.0 {
				None
			} else {
				Some(numerator / denominator)
			}
		}
		
		fn main() {
			let result = divide(10.0, 2.0);
			
			match result {
				Some(value) => println!("Result: {}", value),
				None => println!("Cannot divide by zero!"),
			}
		}
	\end{lstlisting}
	
	\textbf{How It Works:}
	\begin{itemize}
		\item If the denominator is nonzero, we return \texttt{Some(result)}.
		\item If the denominator is zero, we return \texttt{None}, explicitly indicating an invalid operation.
		\item The \texttt{match} statement is then used to handle both cases safely.
	\end{itemize}
	
	\subsection*{Approach 2: The \texttt{Result<T, E>} Enum}
	
	While \texttt{Option<T>} is useful for cases where failure simply means "no value," sometimes we need more details about the error. This is where \texttt{Result<T, E>} comes in. It provides either:
	\begin{itemize}
		\item \texttt{Ok(T)} – representing success with a value of type \texttt{T}.
		\item \texttt{Err(E)} – representing failure with an error message (type \texttt{E}).
	\end{itemize}
	
	\begin{lstlisting}[language=Rust]
		// Defining the Result type (already built into Rust)
		enum Result<T, E> {
			Ok(T),  // Represents success
			Err(E), // Represents an error
		}
		
		// Function that safely performs division using Result<T, E>
		fn divide_result(numerator: f64, denominator: f64) -> Result<f64, String> {
			if denominator == 0.0 {
				Err("Cannot divide by 0".to_string())
			} else {
				Ok(numerator / denominator)
			}
		}
		
		fn main() {
			match divide_result(100.23, 73.98) {
				Ok(result) => println!("Result: {}", result),
				Err(error) => println!("Error: {}", error),
			}
		}
	\end{lstlisting}
	
	\textbf{Why Use \texttt{Result<T, E>}?}
	\begin{itemize}
		\item It provides more detailed error handling.
		\item The \texttt{Err} variant can store useful debugging information.
		\item It's widely used in Rust’s standard library for error-prone operations (e.g., file handling, network operations).
	\end{itemize}
	
	\begin{takeawaybox}
		
		\begin{itemize}
			\item Use \texttt{Option<T>} when a value might be present or absent.
			\item Use \texttt{Result<T, E>} when an operation can fail and you need to know why.
			\item Both approaches help enforce safer error handling in Rust.
		\end{itemize}
	\end{takeawaybox}
	
	
	% Working with Collections in Rust: Vectors and Strings
	%------------------------------------------------------
	\section{Collections: Vectors and Strings}
	
	Rust provides powerful collection types to manage dynamically sized data. In this section, we explore \texttt{Vec<T>} for storing lists of elements and \texttt{String} for handling text.
	
	\section*{Vectors: The Dynamic List in Rust}
	
	Vectors (\texttt{Vec<T>}) allow you to store multiple values of the same type in a dynamically sized array. Unlike arrays, vectors can grow and shrink at runtime.
	
	\subsection*{Creating and Modifying Vectors}
	
	You can create an empty vector or use the \texttt{vec![]} macro to initialize it with values:
	
	\begin{lstlisting}[language=Rust]
		// Creating an empty vector
		let mut v: Vec<i32> = Vec::new();  
		
		// Creating a vector with initial values
		let mut v = vec![1, 2, 3]; 
		
		// Adding elements dynamically
		v.push(5);
		v.push(6);
		v.push(7);
		
		println!("The numbers vector is {:?}", v);
	\end{lstlisting}
	
	\begin{takeawaybox}
	\begin{itemize}
		\item Vectors are mutable by default only if explicitly declared as \texttt{mut}.
		\item Use \texttt{push()} to add elements dynamically.
	\end{itemize}
	
	\end{takeawaybox}
	
	\subsection*{Accessing Elements in a Vector}
	
	There are two ways to access vector elements: direct indexing and the \texttt{get()} method.
	
	\begin{lstlisting}[language=Rust]
		let v = vec![1, 2, 3, 4, 5];
		
		// Direct indexing (panics if out of bounds)
		let third: &i32 = &v[2];
		println!("The third element is: {third}");
		
		// Using get() method (returns Option<&T>)
		match v.get(5) {
			Some(value) => println!("The value is {value}"),
			None => println!("No value at this index"),
		}
	\end{lstlisting}
	
	\noindent\textbf{Why Use \texttt{get()} Instead of Direct Indexing?}
	\begin{itemize}
		\item Direct indexing (\texttt{v[index]}) will cause a panic if the index is out of bounds.
		\item \texttt{get()} returns an \texttt{Option<T>}, allowing safe error handling.
	\end{itemize}
	
	\section*{Strings in Rust: More Than Just Text}
	
	Unlike simple string literals (\texttt{\&str}), Rust provides a heap-allocated \texttt{String} type that can be modified dynamically.
	
	\subsection*{Creating and Mutating Strings}
	
	\begin{lstlisting}[language=Rust]
		// Creating a String from a string literal
		let mut s = String::from("foo");
		
		// Appending a string slice
		s.push_str("bar");
		
		// Appending a single character
		s.push('!');
		
		println!("The value of s = {}", s);
	\end{lstlisting}
	
	\noindent\textbf{Key Notes:}
	\begin{itemize}
		\item \texttt{push\_str()} appends a string slice.
		\item \texttt{push()} appends a single character.
	\end{itemize}
	
	\subsection*{Concatenating Strings}
	
	Rust doesn’t allow simple string concatenation with \texttt{+} without borrowing. The \texttt{+} operator moves the first string, while the second is borrowed.
	
	\begin{lstlisting}[language=Rust]
		let s1 = String::from("Hello, ");
		let s2 = String::from("world!");
		
		// s1 is moved and cannot be used again
		let s3 = s1 + &s2;  
		println!("The value of s3 = {}", s3);
	\end{lstlisting}
	
	\subsection*{Using \texttt{format!()} for String Composition}
	
	If you need to concatenate multiple strings without taking ownership, \texttt{format!()} is a better approach.
	
	\begin{lstlisting}[language=Rust]
		let salut = String::from("Salut");
		
		let full_message = format!("{salam} {salut}");
		println!("{}", full_message);
	\end{lstlisting}
	
	\noindent\textbf{Why Use \texttt{format!()}?}
	\begin{itemize}
		\item It doesn’t take ownership of any of the strings.
		\item It’s more readable and flexible for combining multiple values.
	\end{itemize}
	
	\begin{takeawaybox}
	
		\begin{itemize}
			\item Use \texttt{Vec<T>} when you need a resizable array.
			\item Access elements safely using \texttt{get()} instead of direct indexing.
			\item Strings in Rust are heap-allocated and must be managed explicitly.
			\item Use \texttt{push\_str()} and \texttt{push()} to modify a \texttt{String}.
			\item Use \texttt{format!()} for efficient string concatenation.
		\end{itemize}
	\end{takeawaybox}
	
	
	
	\section{Collections: Hash Maps in Rust}
	
	In Rust, a HashMap is a collection that stores data in key-value pairs, making it ideal for scenarios where you need quick lookups based on unique identifiers. In this section, we’ll explore how to use \texttt{HashMap} to store and manage data dynamically.
	
	\section*{Hash Maps: Associative Arrays in Rust}
	
	A \texttt{HashMap} is an unordered collection that maps keys to values. It is particularly useful when you need to associate one piece of data (a key) with another (a value), and allows for fast lookup, insertion, and deletion operations.
	
	\subsection*{Creating and Modifying Hash Maps}
	
	You can create an empty \texttt{HashMap} and add key-value pairs using the \texttt{insert()} method. Here’s how you can initialize a \texttt{HashMap} and populate it with data:
	
	\begin{lstlisting}[language=Rust]
		// Import HashMap from the standard library
		use std::collections::HashMap;
		
		fn main() {
			// Create a new, empty HashMap
			let mut scores = HashMap::new();
			
			// Insert key-value pairs into the HashMap
			scores.insert(String::from("Blue"), 10);
			scores.insert(String::from("Yellow"), 50);
			
			// Print the contents of the HashMap
			for (team, score) in &scores {
				println!("{team}: {score}");
			}
		}
	\end{lstlisting}
	
	\noindent\textbf{Key Points:}
	\begin{itemize}
		\item HashMaps are created using \texttt{HashMap::new()} and are mutable by default if declared with \texttt{mut}.
		\item Use \texttt{insert()} to add key-value pairs.
	\end{itemize}
	
	\subsection*{Accessing Values in a HashMap}
	
	To access values stored in a HashMap, you can use the \texttt{get()} method, which returns an \texttt{Option} type. If the key is found, \texttt{get()} will return \texttt{Some(value)}, and if the key doesn’t exist, it will return \texttt{None}. Here's an example of how to retrieve a value:
	
	\begin{lstlisting}[language=Rust]
		let team_name = String::from("Blue");
		let score = scores.get(&team_name).copied().unwrap_or(0);
		println!("The score for team {team_name} is: {score}");
	\end{lstlisting}
	
	\noindent\textbf{Why Use \texttt{get()}?}
	\begin{itemize}
		\item The \texttt{get()} method allows you to safely retrieve a value without causing a panic if the key is not found.
		\item By using \texttt{copied()}, we ensure the value is returned by value, not by reference.
	\end{itemize}
	
	\subsection*{Modifying and Removing Entries}
	
	You can modify existing values in a HashMap or remove entries using the \texttt{insert()} and \texttt{remove()} methods. Here’s how to modify a value and remove an entry:
	
	\begin{lstlisting}[language=Rust]
		// Modify the score for a team
		scores.insert(String::from("Blue"), 20);  // Updating "Blue" team's score
		
		// Remove a team from the HashMap
		scores.remove(&String::from("Yellow"));
	\end{lstlisting}
	
	\subsection*{Iterating Over a HashMap}
	
	To iterate over all the key-value pairs in a HashMap, you can use a \texttt{for} loop. Each iteration gives you a reference to a key and a value, allowing you to process them as needed:
	
	\begin{lstlisting}[language=Rust]
		for (key, value) in &scores {
			println!("{key}: {value}");
		}
	\end{lstlisting}
	
	\noindent\textbf{Why Use HashMaps?}
	\begin{itemize}
		\item HashMaps provide fast lookups, insertions, and deletions.
		\item The key-value pairing is perfect for associating related data (like team names and scores).
		\item It’s ideal for use cases where you need to map unique keys to specific values (e.g., user IDs to user data).
	\end{itemize}
	
	\begin{takeawaybox}
		
		\begin{itemize}
			\item Use \texttt{HashMap} to store data in key-value pairs.
			\item The \texttt{insert()} method allows adding or updating data.
			\item Use \texttt{get()} to safely retrieve values from the HashMap.
			\item You can modify values or remove entries with \texttt{insert()} and \texttt{remove()}.
			\item Iterating over a HashMap can be done using a \texttt{for} loop.
		\end{itemize}
	\end{takeawaybox}
	
	
\vspace{1cm}	
	
	
	
\noindent \textcolor{rustorange}{\textbf{Note:}} 
This document provides a starting point for learning Rust. You are encouraged to explore Rust further through projects and by referring to the official documentation.

	

	
	
	\bibliographystyle{plain}
	\bibliography{references}
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	
	
	
	
	
	
	
	
	
	
\end{document}
